"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Base58 = require("base-58");
var sodium = require("libsodium-wrappers");
var DIDComm = /** @class */ (function () {
    /**
     * Creates a new PackUnpack object. The returned object contains a .Ready property:
     * a promise that must be resolved before the object can be used. You can
     * simply `await` the resolution of the .Ready property.
     *
     * Example:
     * const packUnpack = new PackUnpack
     * (async () => {
     *  await packUnpack.Ready
     * }())
     */
    function DIDComm() {
        var _this = this;
        this.Ready = new Promise(function (res, rej) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, sodium.ready];
                    case 1:
                        _a.sent();
                        this.sodium = sodium;
                        res();
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _a.sent();
                        rej(err_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    }
    /**
     *
     * Packs a message.
     * @param message string message to be encrypted
     * @param toKeys public key of the entity encrypting message for
     * @param fromKeys keypair of person encrypting message
     */
    DIDComm.prototype.packMessage = function (message, toKeys, fromKeys) {
        if (fromKeys === void 0) { fromKeys = null; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, recipsJson, cek, recipsB64, _b, ciphertext, tag, iv;
            return tslib_1.__generator(this, function (_c) {
                _a = this.prepareRecipientKeys(toKeys, fromKeys), recipsJson = _a[0], cek = _a[1];
                recipsB64 = this.b64url(recipsJson);
                _b = this.encryptPlaintext(message, recipsB64, cek), ciphertext = _b[0], tag = _b[1], iv = _b[2];
                return [2 /*return*/, JSON.stringify({
                        ciphertext: this.b64url(ciphertext),
                        iv: this.b64url(iv),
                        protected: recipsB64,
                        tag: this.b64url(tag),
                    })];
            });
        });
    };
    /**
     * Unpacks a message
     * @param encMsg message to be decrypted
     * @param toKeys key pair of party decrypting the message
     */
    DIDComm.prototype.unpackMessage = function (encMsg, toKeys) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var wrapper, recipsJson, recipsOuter, alg, isAuthcrypt, _a, cek, senderVk, recipVk, ciphertext, nonce, tag, message;
            return tslib_1.__generator(this, function (_b) {
                if (typeof encMsg === 'string') {
                    wrapper = JSON.parse(encMsg);
                }
                else {
                    wrapper = encMsg;
                }
                if (typeof toKeys.publicKey === 'string') {
                    toKeys.publicKey = Base58.decode(toKeys.publicKey);
                }
                if (typeof toKeys.privateKey === 'string') {
                    toKeys.privateKey = Base58.decode(toKeys.privateKey);
                }
                recipsJson = this.strB64dec(wrapper.protected);
                recipsOuter = JSON.parse(recipsJson);
                alg = recipsOuter.alg;
                isAuthcrypt = alg === 'Authcrypt';
                if (!isAuthcrypt && alg !== 'Anoncrypt') {
                    throw new Error('Unsupported pack algorithm: ' + alg);
                }
                _a = this.locateRecKey(recipsOuter.recipients, toKeys), cek = _a[0], senderVk = _a[1], recipVk = _a[2];
                if (!senderVk && isAuthcrypt) {
                    throw new Error('Sender public key not provided in Authcrypt message');
                }
                ciphertext = this.b64dec(wrapper.ciphertext);
                nonce = this.b64dec(wrapper.iv);
                tag = this.b64dec(wrapper.tag);
                message = this.decryptPlaintext(ciphertext, tag, wrapper.protected, nonce, cek);
                return [2 /*return*/, {
                        message: message,
                        recipientKey: recipVk,
                        senderKey: senderVk,
                    }];
            });
        });
    };
    /**
     * Uses libsodium to generate a key pair, you may pass these keys into the pack/unpack functions
     */
    DIDComm.prototype.generateKeyPair = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.sodium.crypto_sign_keypair()];
            });
        });
    };
    DIDComm.prototype.b64url = function (input) {
        return this.sodium.to_base64(input, this.sodium.base64_variants.URLSAFE);
    };
    DIDComm.prototype.b64dec = function (input) {
        return this.sodium.from_base64(input, this.sodium.base64_variants.URLSAFE);
    };
    DIDComm.prototype.strB64dec = function (input) {
        return this.sodium.to_string(this.sodium.from_base64(input, this.sodium.base64_variants.URLSAFE));
    };
    DIDComm.prototype.encryptPlaintext = function (message, addData, key) {
        var iv = this.sodium.randombytes_buf(this.sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES);
        var out = this.sodium.crypto_aead_chacha20poly1305_ietf_encrypt_detached(message, addData, null, iv, key);
        return [out.ciphertext, out.mac, iv];
    };
    DIDComm.prototype.decryptPlaintext = function (ciphertext, mac, recipsBin, nonce, key) {
        return this.sodium.to_string(this.sodium.crypto_aead_chacha20poly1305_ietf_decrypt_detached(null, // nsec
        ciphertext, mac, recipsBin, // ad
        nonce, // npub
        key));
    };
    DIDComm.prototype.prepareRecipientKeys = function (toKeys, fromKeys) {
        var _this = this;
        if (fromKeys === void 0) { fromKeys = null; }
        var cek = this.sodium.crypto_aead_chacha20poly1305_ietf_keygen();
        var recips = [];
        toKeys.forEach(function (targetVk) {
            var encCek = null;
            var encSender = null;
            var nonce = null;
            var targetPk = _this.sodium.crypto_sign_ed25519_pk_to_curve25519(targetVk);
            if (fromKeys) {
                var senderVk = Base58.encode(fromKeys.publicKey);
                var senderSk = _this.sodium.crypto_sign_ed25519_sk_to_curve25519(fromKeys.privateKey);
                encSender = _this.sodium.crypto_box_seal(senderVk, targetPk);
                nonce = _this.sodium.randombytes_buf(_this.sodium.crypto_box_NONCEBYTES);
                encCek = _this.sodium.crypto_box_easy(cek, nonce, targetPk, senderSk);
            }
            else {
                encCek = _this.sodium.crypto_box_seal(cek, targetPk);
            }
            recips.push({
                encrypted_key: _this.b64url(encCek),
                header: {
                    iv: nonce ? _this.b64url(nonce) : null,
                    kid: Base58.encode(targetVk),
                    sender: encSender ? _this.b64url(encSender) : null,
                },
            });
        });
        var data = {
            alg: fromKeys ? 'Authcrypt' : 'Anoncrypt',
            enc: 'chacha20poly1305_ietf',
            recipients: recips,
            typ: 'JWM/1.0',
        };
        return [JSON.stringify(data), cek];
    };
    DIDComm.prototype.locateRecKey = function (recipients, keys) {
        var notFound = [];
        /* tslint:disable */
        for (var index in recipients) {
            var recip = recipients[index];
            if (!('header' in recip) || !('encrypted_key' in recip)) {
                throw new Error('Invalid recipient header');
            }
            var recipVk = Base58.decode(recip.header.kid);
            if (!this.sodium.memcmp(recipVk, keys.publicKey)) {
                notFound.push(recip.header.kid);
            }
            var pk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(keys.publicKey);
            var sk = this.sodium.crypto_sign_ed25519_sk_to_curve25519(keys.privateKey);
            var encrytpedKey = this.b64dec(recip.encrypted_key);
            var nonce = recip.header.iv ? this.b64dec(recip.header.iv) : null;
            var encSender = recip.header.sender ? this.b64dec(recip.header.sender) : null;
            var senderVk = null;
            var cek = null;
            if (nonce && encSender) {
                senderVk = this.sodium.to_string(this.sodium.crypto_box_seal_open(encSender, pk, sk));
                var senderPk = this.sodium.crypto_sign_ed25519_pk_to_curve25519(Base58.decode(senderVk));
                cek = this.sodium.crypto_box_open_easy(encrytpedKey, nonce, senderPk, sk);
            }
            else {
                cek = this.sodium.crypto_box_seal_open(encrytpedKey, pk, sk);
            }
            return [cek, senderVk, recip.header.kid];
        }
        throw new Error('No corresponding recipient key found in recipients');
    };
    return DIDComm;
}());
exports.DIDComm = DIDComm;
//# sourceMappingURL=index.js.map